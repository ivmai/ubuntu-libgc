Origin: http://anonscm.debian.org/gitweb/?p=collab-maint/libgc.git;a=commitdiff;h=4dd893dc29bdf10a61734cfc863ec035364c72e7
From be9df82919960214ee4b9d3313523bff44fd99e1 Mon Sep 17 00:00:00 2001
From: Xi Wang <xi.wang@gmail.com>
Date: Thu, 15 Mar 2012 04:55:08 +0800
Subject: [PATCH] Fix allocation size overflows due to rounding.

* malloc.c (GC_generic_malloc): Check if the allocation size is
  rounded to a smaller value.
* mallocx.c (GC_generic_malloc_ignore_off_page): Likewise.

From e10c1eb9908c2774c16b3148b30d2f3823d66a9a Mon Sep 17 00:00:00 2001
From: Xi Wang <xi.wang@gmail.com>
Date: Thu, 15 Mar 2012 04:46:49 +0800
Subject: [PATCH] Fix calloc() overflow

* malloc.c (calloc): Check multiplication overflow in calloc(),
  assuming REDIRECT_MALLOC.

From 6a93f8e5bcad22137f41b6c60a1c7384baaec2b3 Mon Sep 17 00:00:00 2001
From: Ivan Maidanski <ivmai@mail.ru>
Date: Thu, 15 Mar 2012 20:30:11 +0400
Subject: [PATCH] Fix calloc-related code to prevent SIZE_MAX
 redefinition in sys headers

 * malloc.c: Include limits.h for SIZE_MAX.
 * malloc.c (SIZE_MAX, calloc): Define GC_SIZE_MAX instead of SIZE_MAX.

From 83231d0ab5ed60015797c3d1ad9056295ac3b2bb Mon Sep 17 00:00:00 2001
From: Hans Boehm <Hans.Boehm@hp.com>
Date: Thu, 15 Mar 2012 21:09:05 +0400
Subject: [PATCH] Speedup calloc size overflow check by preventing
 division if small values

 * malloc.c (GC_SQRT_SIZE_MAX): New macro.
 * malloc.c (calloc): Add fast initial size overflow check to avoid
   integer division for reasonably small values passed.

CVE-2012-2673

[Ubuntu note: merged 4 patches into a single patch and backport to
 6.8 codebase, based on the debian/upstream patches. -sbeattie]

--
 malloc.c  |   17 +++++++++++++++++
 mallocx.c |    5 +++++
 2 files changed, 22 insertions(+)

Index: b/malloc.c
===================================================================
--- a/malloc.c
+++ b/malloc.c
@@ -197,8 +197,13 @@ register int k;
     } else {
 	word lw;
 	word n_blocks;
+	size_t lb_rounded;
 	GC_bool init;
 	lw = ROUNDED_UP_WORDS(lb);
+	lb_rounded = WORDS_TO_BYTES(lw);
+	if (lb_rounded < lb)
+	  return((*GC_oom_fn)(lb));
+
 	n_blocks = OBJ_SZ_TO_BLOCKS(lw);
 	init = GC_obj_kinds[k].ok_init;
 	DISABLE_SIGNALS();
@@ -377,6 +382,15 @@ DCL_LOCK_STATE;
     return((GC_PTR)REDIRECT_MALLOC(lb));
   }
 
+#include <limits.h>
+#ifdef SIZE_MAX
+# define GC_SIZE_MAX SIZE_MAX
+#else
+# define GC_SIZE_MAX (~(size_t)0)
+#endif
+
+#define GC_SQRT_SIZE_MAX ((1U << (WORDSZ / 2)) - 1)
+
 # ifdef __STDC__
     GC_PTR calloc(size_t n, size_t lb)
 # else
@@ -384,6 +398,9 @@ DCL_LOCK_STATE;
     size_t n, lb;
 # endif
   {
+    if ((lb | n) > GC_SQRT_SIZE_MAX /* fast initial test */
+        && lb && n > GC_SIZE_MAX / lb)
+      return NULL;
     return((GC_PTR)REDIRECT_MALLOC(n*lb));
   }
 
Index: b/mallocx.c
===================================================================
--- a/mallocx.c
+++ b/mallocx.c
@@ -181,6 +181,7 @@ register int k;
 {
     register ptr_t result;
     word lw;
+    size_t lb_rounded;
     word n_blocks;
     GC_bool init;
     DCL_LOCK_STATE;
@@ -188,6 +189,10 @@ register int k;
     if (SMALL_OBJ(lb))
         return(GC_generic_malloc((word)lb, k));
     lw = ROUNDED_UP_WORDS(lb);
+    lb_rounded = WORDS_TO_BYTES(lw);
+    if (lb_rounded < lb)
+        return((*GC_oom_fn)(lb));
+
     n_blocks = OBJ_SZ_TO_BLOCKS(lw);
     init = GC_obj_kinds[k].ok_init;
     if (GC_have_errors) GC_print_all_errors();
