commit 175b8d2c17a37fddbd76302baf42d73688b8bccb
Author: Ivan Maidanski <ivmai@mail.ru>
Date:   Sun Mar 30 12:31:49 2014 +0400
Description: Fix GET_MEM argument rounding in GC_scratch_alloc and similar

    Fix GET_MEM argument rounding in GC_scratch_alloc and similar
    (Prevent abort in GC_unix_mmap_get_mem if the allocation size is not
    a multiple of a page size.)
    (Apply commit 62bfeb0 from 'release-7_4' branch.)
    
    * backgraph.c (new_back_edges, push_in_progress): Use
    ROUNDUP_PAGESIZE_IF_MMAP() to adjust GET_MEM() argument (when needed).
    * headers.c (GC_scratch_alloc): Likewise.
    * misc.c (GC_envfile_init): Likewise.
    * include/private/gc_priv.h (ROUNDUP_PAGESIZE_IF_MMAP): New macro.
    * include/private/gcconfig.h (MMAP_SUPPORTED): Move definition from
    os_dep.c (as needed for ROUNDUP_PAGESIZE_IF_MMAP() definition).
    * include/private/gcconfig.h (GET_MEM): Refine comment (regarding its
    argument).
    
    Conflicts:
    
        include/private/gcconfig.h
        os_dep.c

diff --git a/backgraph.c b/backgraph.c
index b0193e3..79dcecf 100644
--- a/backgraph.c
+++ b/backgraph.c
@@ -86,8 +86,9 @@ static back_edges *avail_back_edges = 0;
 static back_edges * new_back_edges(void)
 {
   if (0 == back_edge_space) {
-    back_edge_space = (back_edges *)
-                        GET_MEM(MAX_BACK_EDGE_STRUCTS*sizeof(back_edges));
+    back_edge_space = (back_edges *)GET_MEM(
+                        ROUNDUP_PAGESIZE_IF_MMAP(MAX_BACK_EDGE_STRUCTS
+                                                  * sizeof(back_edges)));
     GC_add_to_our_memory((ptr_t)back_edge_space,
                          MAX_BACK_EDGE_STRUCTS*sizeof(back_edges));
   }
@@ -127,7 +128,9 @@ static void push_in_progress(ptr_t p)
 {
   if (n_in_progress >= in_progress_size) {
     if (in_progress_size == 0) {
-      in_progress_size = INITIAL_IN_PROGRESS;
+      in_progress_size = ROUNDUP_PAGESIZE_IF_MMAP(INITIAL_IN_PROGRESS
+                                                        * sizeof(ptr_t))
+                                / sizeof(ptr_t);
       in_progress_space = (ptr_t *)GET_MEM(in_progress_size * sizeof(ptr_t));
       GC_add_to_our_memory((ptr_t)in_progress_space,
                            in_progress_size * sizeof(ptr_t));
diff --git a/headers.c b/headers.c
index eac3e9f..8aeb04a 100644
--- a/headers.c
+++ b/headers.c
@@ -130,28 +130,22 @@ GC_INNER ptr_t GC_scratch_alloc(size_t bytes)
 
         if (bytes_to_get <= bytes) {
           /* Undo the damage, and get memory directly */
-            bytes_to_get = bytes;
-#           ifdef USE_MMAP
-                bytes_to_get += GC_page_size - 1;
-                bytes_to_get &= ~(GC_page_size - 1);
-#           endif
+            bytes_to_get = ROUNDUP_PAGESIZE_IF_MMAP(bytes);
             result = (ptr_t)GET_MEM(bytes_to_get);
             GC_add_to_our_memory(result, bytes_to_get);
             scratch_free_ptr -= bytes;
             GC_scratch_last_end_ptr = result + bytes;
             return(result);
         }
+
+        bytes_to_get = ROUNDUP_PAGESIZE_IF_MMAP(bytes_to_get); /* for safety */
         result = (ptr_t)GET_MEM(bytes_to_get);
         GC_add_to_our_memory(result, bytes_to_get);
         if (result == 0) {
             if (GC_print_stats)
                 GC_log_printf("Out of memory - trying to allocate less\n");
             scratch_free_ptr -= bytes;
-            bytes_to_get = bytes;
-#           ifdef USE_MMAP
-                bytes_to_get += GC_page_size - 1;
-                bytes_to_get &= ~(GC_page_size - 1);
-#           endif
+            bytes_to_get = ROUNDUP_PAGESIZE_IF_MMAP(bytes);
             result = (ptr_t)GET_MEM(bytes_to_get);
             GC_add_to_our_memory(result, bytes_to_get);
             return result;
diff --git a/include/private/gc_priv.h b/include/private/gc_priv.h
index 3fdb687..0e0fbae 100644
--- a/include/private/gc_priv.h
+++ b/include/private/gc_priv.h
@@ -1288,6 +1288,18 @@ GC_EXTERN word GC_n_heap_sects; /* Number of separately added heap      */
 
 GC_EXTERN word GC_page_size;
 
+/* Round up allocation size to a multiple of a page size.       */
+/* GC_setpagesize() is assumed to be already invoked.           */
+#define ROUNDUP_PAGESIZE(bytes) \
+                (((bytes) + GC_page_size - 1) & ~(GC_page_size - 1))
+
+/* Same as above but used to make GET_MEM() argument safe.      */
+#ifdef MMAP_SUPPORTED
+# define ROUNDUP_PAGESIZE_IF_MMAP(bytes) ROUNDUP_PAGESIZE(bytes)
+#else
+# define ROUNDUP_PAGESIZE_IF_MMAP(bytes) (bytes)
+#endif
+
 #if defined(MSWIN32) || defined(MSWINCE) || defined(CYGWIN32)
   struct _SYSTEM_INFO;
   GC_EXTERN struct _SYSTEM_INFO GC_sysinfo;
diff --git a/include/private/gcconfig.h b/include/private/gcconfig.h
index bea1a76..f5b62a7 100644
--- a/include/private/gcconfig.h
+++ b/include/private/gcconfig.h
@@ -2459,6 +2459,12 @@
 # define GC_DISABLE_INCREMENTAL
 #endif
 
+#if defined(LINUX) || defined(FREEBSD) || defined(SOLARIS) || defined(IRIX5) \
+        || ((defined(USE_MMAP) || defined(USE_MUNMAP)) \
+        && !defined(MSWIN32) && !defined(MSWINCE))
+# define MMAP_SUPPORTED
+#endif
+
 #if defined(GC_DISABLE_INCREMENTAL) || defined(MANUAL_VDB)
 # undef GWW_VDB
 # undef MPROTECT_VDB
@@ -2770,8 +2776,8 @@
         /* REDIRECT_MALLOC macro defined.                               */
         /* GET_MEM() returns a HLKSIZE aligned chunk.                   */
         /* 0 is taken to mean failure.                                  */
-        /* In the case os USE_MMAP, the argument must also be a         */
-        /* physical page size.                                          */
+        /* In case of MMAP_SUPPORTED, the argument must also be         */
+        /* a multiple of a physical page size.                          */
         /* GET_MEM is currently not assumed to retrieve 0 filled space, */
         /* though we should perhaps take advantage of the case in which */
         /* does.                                                        */
diff --git a/misc.c b/misc.c
index 5bc689d..91e218a 100644
--- a/misc.c
+++ b/misc.c
@@ -542,7 +542,7 @@ GC_API void GC_CALL GC_get_heap_usage_safe(GC_word *pheap_size,
       }
       /* At this execution point, GC_setpagesize() and GC_init_win32()  */
       /* must already be called (for GET_MEM() to work correctly).      */
-      content = (char *)GET_MEM(len + 1);
+      content = (char *)GET_MEM(ROUNDUP_PAGESIZE_IF_MMAP(len + 1));
       if (content == NULL) {
         CloseHandle(hFile);
         return; /* allocation failure */
diff --git a/os_dep.c b/os_dep.c
index 25bd568..e6283ac 100644
--- a/os_dep.c
+++ b/os_dep.c
@@ -97,12 +97,6 @@
 # include <malloc.h>   /* for locking */
 #endif
 
-#if defined(LINUX) || defined(FREEBSD) || defined(SOLARIS) || defined(IRIX5) \
-        || ((defined(USE_MMAP) || defined(USE_MUNMAP)) \
-        && !defined(MSWIN32) && !defined(MSWINCE))
-# define MMAP_SUPPORTED
-#endif
-
 #if defined(MMAP_SUPPORTED) || defined(ADD_HEAP_GUARD_PAGES)
 # if defined(USE_MUNMAP) && !defined(USE_MMAP)
 #   error "invalid config - USE_MUNMAP requires USE_MMAP"
